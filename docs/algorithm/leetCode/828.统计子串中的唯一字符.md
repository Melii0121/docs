# 828. 统计子串中的唯一字符

## 题意
我们定义了一个函数 countUniqueChars(s) 来统计字符串 s 中的唯一字符，并返回唯一字符的个数。

例如：s = "LEETCODE" ，则其中 "L", "T","C","O","D" 都是唯一字符，因为它们只出现一次，所以 countUniqueChars(s) = 5 。

本题将会给你一个字符串 s ，我们需要返回 countUniqueChars(t) 的总和，其中 t 是 s 的子字符串。输入用例保证返回值为 32 位整数。

注意，某些子字符串可能是重复的，但你统计时也必须算上这些重复的子字符串（也就是说，你必须统计 s 的所有子字符串中的唯一字符）。


- 示例 1：
    ```
    输入: s = "ABC"
    输出: 10
    解释: 所有可能的子串为："A","B","C","AB","BC" 和 "ABC"。
        其中，每一个子串都由独特字符构成。
        所以其长度总和为：1 + 1 + 1 + 2 + 2 + 3 = 10
    ```
- 示例 2：
    ```
    输入: s = "ABA"
    输出: 8
    解释: 除了 countUniqueChars("ABA") = 1 之外，其余与示例 1 相同。
    ```

- 示例 3：
    ```
    输入：s = "LEETCODE"
    输出：92
    ```

提示：
- 1 <= s.length <= 10^5
- s 只包含大写英文字符

## 思考

重点在于计算指定字符所做的贡献值

---
### 计算区间

得到所有字符所出现的位置 `(-1,x,x,x,s.length)` (x为位置下表)，因为如果一个字符出现两次以上就不会有贡献，所以我们要求出一个字符左右相邻最近的相同字符，并求出在此区间内容贡献值大小

设: 左侧值下标为 `l` 右侧值下标为 `r` 当前计算字符位置为 `i`, 此字符s[i] 在此区间所作的贡献可以写为 `(i-l) * (r-i)`, 对所有字符的区间都如此获取并相加就能得到 所有字串中唯一字符的总数量

如字符 `BCDFGD` 中的 `D` 字符最终得到的下标集合为 `(-1, 2, 5, 6)`,
则 D 字符所作总贡献为 (2-(-1))*(5-2) + (5-2)*(6-5) = 9 + 3 = 12


```java
class Solution {
  public int uniqueLetterStringForSection(String s) {
    Map<Character, List<Integer>> index = new HashMap<Character, List<Integer>>();
    for (int i = 0; i < s.length(); i++) {
      char c = s.charAt(i);
      if (!index.containsKey(c)) {
        index.put(c, new ArrayList<Integer>());
        index.get(c).add(-1);
      }
      index.get(c).add(i);
    }
    int res = 0;
    for (Map.Entry<Character, List<Integer>> entry : index.entrySet()) {
      List<Integer> arr = entry.getValue();
      arr.add(s.length());
      for (int i = 1; i < arr.size() - 1; i++) {
        res += (arr.get(i) - arr.get(i - 1)) * (arr.get(i + 1) - arr.get(i));
      }
    }
    return res;
  }
}
```

---
### 变化量比较

- 将所有子串按照其末尾字符的下标分组。
- 考虑两组相邻的子串：以 `s[i-1]` 结尾的子串、以 `s[i]` 结尾的子串。
- 以 `s[i]` 结尾的子串，可以看成是以 `s[i-1]` 结尾的子串，在末尾添加上 `s[i]` 组成。

即以字符串 `BCADEAFGA` 进行解释，可以理解为 `BCAD` 字符在结尾加上 `E` 字符得到 `BCADE` 字符串，又在 `BCADE` 字符串结尾加上 `A` 字符串得到 `BCADEA` 字符串，以此类推。


- A 可以单独作为一个子串，其 countUniqueChars 值为 `1`；
- 往子串 `G` 和 `FG` 的末尾添加 `A`，由于 `A` 不在这些子串中，因此这些子串的 countUniqueChars 值都会增加 `1`；
- 往子串 `AFG`、`EAFG` 和 `DEAFG` 的末尾添加 `A`，由于 `A` 已经在这些子串中且恰好出现一次，添加后 `A` 重复出现，因此这些子串的 countUniqueChars 值都会减少 1；
  往子串 `ADEAFG`、`CADEAFG` 和 `BCADEAFG` 的末尾添加 `A`，由于 `A` 已经在这些子串中且不止出现一次，因此添加 `A` 不会改变这些子串的 countUniqueChars 值。

记录上次出现的下标为 `o`, 上上次出现的下标为 `t`, 当前下表为 `i`。  
「以 `s[i-1]` 结尾的子串」到「以 `s[i]` 结尾的子串」 的countUniqueChars， 增加/减少了多少：
- 新增的数量为： `i - t`
- 减少的数量为： `t - o`
- 则总变化量为： `i - 2t + o`

```java
class Solution {
  public int uniqueLetterStringForVariation(String s) {
    int ans = 0, total = 0;
    int[] last0 = new int[26], last1 = new int[26];
    Arrays.fill(last0, -1);
    Arrays.fill(last1, -1);
    for (int i = 0; i < s.length(); i++) {
      int c = s.charAt(i) - 'A';
      total += i - 2 * last0[c] + last1[c];
      ans += total;
      last1[c] = last0[c];
      last0[c] = i;
    }
    return ans;
  }
}
```
